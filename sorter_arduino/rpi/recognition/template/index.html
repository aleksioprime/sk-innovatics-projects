<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8">
  <title>Intelligent vegetable sorting</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      padding: 20px;
    }

    img {
      border: 1px solid #ccc;
      margin-bottom: 10px;
    }

    .status {
      margin: 10px 0;
      font-weight: bold;
    }

    #log {
      border: 1px solid #ddd;
      height: 150px;
      overflow-y: scroll;
      padding: 10px;
      background: #f9f9f9;
    }

    #log div {
      font-size: 14px;
      margin-bottom: 2px;
    }
  </style>
</head>

<body>
  <h1>Intelligent vegetable sorting</h1>

  <div style="display: flex; align-items: flex-start; gap: 40px;">

    <!-- –õ–µ–≤–∞—è —á–∞—Å—Ç—å: –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ -->
    <div>
      <img src="stream.mjpg" width="480" height="480" />
    </div>

    <!-- –ü—Ä–∞–≤–∞—è —á–∞—Å—Ç—å: —Å—Ç–∞—Ç—É—Å, –∫–Ω–æ–ø–∫–∏ –∏ –ª–æ–≥ -->
    <div style="flex: 1;">
      <div class="status">–°—Ç–∞—Ç—É—Å –ø—Ä–æ–≥—Ä–∞–º–º—ã: <span id="status">–û—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞</span></div>
      <button onclick="sendCommand('START')">–ó–∞–ø—É—Å—Ç–∏—Ç—å</button>
      <button onclick="sendCommand('STOP')">–û—Å—Ç–∞–Ω–æ–≤–∏—Ç—å</button>

      <div class="status">–°–±–æ—Ä –∫–∞–¥—Ä–æ–≤: <span id="collectorStatus">-</span></div>

      <div class="status">–†–∞—Å–ø–æ–∑–Ω–∞–Ω–Ω—ã–π –æ–±—ä–µ–∫—Ç: <span id="recognized">-</span></div>
      <div class="status">–ë—É—Ñ–µ—Ä –ø—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏–π:</div>
      <ul id="buffered" style="padding-left: 20px;"></ul>

      <div style="margin-top: 15px;">
        <input type="text" id="customCommand" placeholder="–í–≤–µ–¥–∏—Ç–µ –∫–æ–º–∞–Ω–¥—É (–Ω–∞–ø—Ä–∏–º–µ—Ä, GOOD)" />
        <button onclick="sendCustomCommand()">–û—Ç–ø—Ä–∞–≤–∏—Ç—å</button>
      </div>

      <h3>–°–æ–æ–±—â–µ–Ω–∏—è –æ—Ç Arduino:</h3>
      <div id="log"></div>
    </div>

  </div>

  <script>
    const logDiv = document.getElementById('log');
    const statusSpan = document.getElementById('status');
    const recognizedSpan = document.getElementById('recognized');
    const bufferedList = document.getElementById('buffered');

    let lastNonEmptyCounts = {};  // üß† —Å—é–¥–∞ —Å–æ—Ö—Ä–∞–Ω–∏–º –ø–æ—Å–ª–µ–¥–Ω–µ–µ –∑–∞–ø–æ–ª–Ω–µ–Ω–∏–µ

    function appendLog(message) {
      const entry = document.createElement('div');
      entry.textContent = message;
      logDiv.appendChild(entry);
      logDiv.scrollTop = logDiv.scrollHeight;
    }

    function updateBufferDisplay(counts) {
      bufferedList.innerHTML = '';
      Object.entries(counts).forEach(([key, value]) => {
        const li = document.createElement('li');
        li.textContent = `${key}: ${value}`;
        if (key === 'good') li.style.color = 'green';
        else if (key === 'bad') li.style.color = 'red';
        else li.style.color = 'gray';
        bufferedList.appendChild(li);
      });
    }

    function sendCommand(cmd) {
      fetch(`/serial/send?cmd=${cmd}`)
        .then(response => response.text())
        .then(text => appendLog(`‚û° –û—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ: ${cmd}`))
        .catch(err => appendLog(`‚ùå –û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏: ${err}`));

      if (cmd === 'START') statusSpan.textContent = '–†–∞–±–æ—Ç–∞–µ—Ç';
      if (cmd === 'STOP') {
        statusSpan.textContent = '–û—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞';
        recognizedSpan.textContent = '-';
      }
    }

    function sendCustomCommand() {
      const input = document.getElementById('customCommand');
      const value = input.value.trim();
      if (value) {
        sendCommand(value);
        input.value = '';
      }
    }

    // –ü–µ—Ä–∏–æ–¥–∏—á–µ—Å–∫–∏ –ø–æ–ª—É—á–∞–µ–º —Å–æ–æ–±—â–µ–Ω–∏—è –æ—Ç Arduino
    setInterval(() => {
      fetch('/serial/log')
        .then(response => response.json())
        .then(data => {
          if (data.messages) {
            logDiv.innerHTML = ''; // –û—á–∏—â–∞–µ–º –ª–æ–≥ –ø–µ—Ä–µ–¥ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ–º
            data.messages.forEach(msg => {
              appendLog(`‚¨Ö Arduino: ${msg}`);
            });
          }
        });
    }, 2000);

    setInterval(() => {
      fetch('/classification/buffer')
        .then(response => response.json())
        .then(data => {
          const counts = data.counts || {};
          if (Object.keys(counts).length > 0) {
            lastNonEmptyCounts = counts; // –°–æ—Ö—Ä–∞–Ω—è–µ–º –ø–æ—Å–ª–µ–¥–Ω–µ–µ –∑–∞–ø–æ–ª–Ω–µ–Ω–∏–µ
            updateBufferDisplay(counts);
          } else {
            // –ù–µ –æ—á–∏—â–∞–µ–º, –æ—Å—Ç–∞–≤–ª—è–µ–º –ø—Ä–µ–¥—ã–¥—É—â–µ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ
            // –ú–æ–∂–Ω–æ –¥–æ–±–∞–≤–∏—Ç—å —Å–µ—Ä—É—é –Ω–∞–¥–ø–∏—Å—å, –µ—Å–ª–∏ —Ö–æ—á–µ—à—å:
            // const li = document.createElement('li');
            // li.textContent = '(–±—É—Ñ–µ—Ä –æ—á–∏—â–µ–Ω)';
            // li.style.color = 'gray';
            // bufferedList.appendChild(li);
          }
        });
    }, 2000);

    setInterval(() => {
      fetch('/classification/result')
        .then(response => response.json())
        .then(data => {
          if (data.recognized) {
            recognizedSpan.textContent = data.recognized;
          }
        });
    }, 2000);

    setInterval(() => {
      fetch('/collection/status')
        .then(response => response.json())
        .then(data => {
          const collectorStatus = document.getElementById('collectorStatus');
          collectorStatus.textContent = data.active ? '–í–ö–õ' : '–í–´–ö–õ';
        });
    }, 2000);

  </script>
</body>

</html>